# 如何部署以及启动该服务器？
    1. 需要Redis和Mysql数据库
    2. Redis中需要储存RSA公钥和私钥，使用set publicKey以及set privateKey命令
    3. 需要创建一张Message表，见server文件夹，user表并不是必须的
    4. Redis需要用到的数据结构包括：
        1).List MQ消息队列
        2).Set URS:用户id，表明是否是好友关系
        3).String publicKey,privateKey，Rsa加密算法的公钥和私钥
    5. 需要在server中开启数据迁移脚本
    6. 为了测试方便，我还在创捷了一个签发token的服务器，只需要启动tokenServer.js
    7. 测试流程 开启main.js，src/server/tokenServer.js，generateToken.js三个进程，用浏览器打开page.html即可测试


# 下面是说明文档
# 这份文件中包含四部分

~~~
src/main.js 是websocket服务器的启动文件
src/config  是配置文件夹
    要创建src/config/mysql.js，并配置数据库 
src/server  内含web测试用文件夹,以及redis到mysql数据迁移进程脚本
~~~


# 即时通信系统（IM）

# 概叙

​	聊天系统采用websocket进行长连接，通过redis进行聊天数据的缓存，并且会另开一个进程来读取redis中的消息队列并将redis中的数据同步到mysql中

# 连接

​	连接时需要携带参数，我们采用URL传递token（wstoken），即wss://ip:port/token

​	该wstoken不同于httptoken，wstoken必须通过http的某一个请求来申请，且有效期只有2分钟

 	约定申请wstoken的请求为 POST  **https://ip/IM/token**

​	wstoken加密信息：

~~~json
{
    "id":"用户id",
    "type":"websocket"
}
~~~

* 如果wstoken不能正确得到解析，或则解密后的数据格式不对，那么服务端会关闭连接

# websocket数据传输协议

### 传输原理

​	客户端发送消息数据包（含id）到服务器，服务器会返回对应id的响应包（A包）=> 这条消息必定会储存在服务端

​	服务端根据数据包内容进行相关的判断

* 如果是指令数据包，返回相关的响应包
* 如果是消息数据包，会返回相应的A包

### 一般格式

~~~json
{
    "id":"时间戳+随机数"  // 与from一起构成了唯一标识
    "from":发送发id,	  // 消息来自于谁，一般是服务端发给客户端会用到这个字段
    "to":接收方id,		  // 消息要发到谁，0代表系统，其它大于0的数字代表其它用户
    "type":"",			
    // 用一个字母来标识，大写字母标识该数据包是指令数据包，具有特殊功能，是发个系统的数据包；
    //小写字母代表消息数据包，是发给其它远程客户端的，这些消息数据包都是要储存到redis再到MySql中的；
    "msg":""			// msg消息内容
}
~~~

### 客户端到服务端

* 数据包格式

~~~json
{
    "id":"时间戳+随机数",  //为消息数据包时，由客户端生成
    "to":用户id,			//服务端会判断该用户是否为你的好友，如果不是好友，无法发送消息，这个是通过redis的set实现的	
    "type":"",			 // 数据包类型
    "msg":""			 // msg消息内容
}
~~~

* type字段分类

  * 指令数据包

    to：值为0

  |  值  |                             解释                             |
  | :--: | :----------------------------------------------------------: |
  |  P   |       ping，用来进行心跳检测的数据包，”msg“可以无内容        |
  |  T   | take order，客户接单后需要从客户端发起T指令数据包，，服务端会根据msg中的id值，生成对应的s数据包发给用户 |
  |  S   | Site，位置数据包，用于更新送货员的地理位置信息，msg信息是一个对象，字段分别是longtitude,latitude |
  |  O   |                   Online，查看用户是否在线                   |
  |  H   | History message，拉取历史信息，需要传递一个时间参数，用来确定范围 |

  * 消息数据包

  |  值  |                           解释                            |
  | :--: | :-------------------------------------------------------: |
  |  t   |              text，文本，最大长度不超过1023               |
  |  i   | image，聊天图片，接收的客户端可以通过这个换取聊天图片信息 |

### 服务端到客户端

* 数据包格式

~~~json
{
    "id":"时间戳+随机数",  //由客户端生成
    "to":用户id,			//服务端会判断该用户是否为你的好友，如果不是好友，无法发送消息，这个是通过redis的set实现的	
    "type":"",
    "msg":""			 // msg消息内容
}
~~~

* type字段分类

  * 指令数据包

    |  值  |                  解释                   |
    | :--: | :-------------------------------------: |
    |  E   |             error，发生错误             |
    |  L   |  Login，根据wstoken已授权登录聊天系统   |
    |  A   |  ACK，确认服务端数据包收到并正确处理了  |
    |  P   |         Pong，ping的返回数据包          |
    |  H   | History Message，服务器储存的历史数据包 |
    |  C   |     Close，服务端强制关闭websocket      |
    |  O   |             Online，对应O包             |
    |  H   |        History message，历史消息        |

  * 消息数据包

    |  值  |                            解释                            |
    | :--: | :--------------------------------------------------------: |
    |  t   |                  text，转发的文本数据包，                  |
    |  i   |          image，转发的图片数据包，msg为聊天图片id          |
    |  s   | System message，系统消息，比如有人接单了，会提供这个数据包 |

### 各数据包举例

**指令数据包**

* 心跳检测:

  功能：做用户在线检测的

  ~~~json
  客户端P:
  {
      "id":数据包的id,
  	 "to":0,
      "type":"P",
      "msg":"ping"
  }
  服务端P：
  {
      "id":对应客户端数据包的id,
  	"to":0,
      "type":"P",
      "msg":"pong"
  }
  ~~~

  

* 其它功能数据包

  ~~~json
  客户端：
  O:
  {
      "id":数据包的id,
      "to":0,
      "type":"O",
      "msg":需要查询的用户id
  }
  
  T：
  {
      "id":数据包的id,
      "to":0,
      "type":"T",
      "msg":order表对应id, // 通过发送这个数据包，服务端会将客户与送货员拉为好友，并且会返回客户的uid，可以更具uid换取用户的昵称和头像信息
  }
  
  S：
  {
      "id":数据包的id,
      "to":0,
      "type":"T",
      "msg":{
          longtitude:百度地图定位数字,
          latitude:百度地铁图定位数字,
      }
  }
  
  服务端：
  // 通过数据包的id来建立发送的数据包和响应数据包的关联性
  E：
  {
      "id":数据包的id,
      "from":0,
      "type":"E",
      "msg":"错误信息" // 一般发生这个错误的原因有很多，比如token错误，用户将你拉黑了等等
  }
  A：
  {
       "id":数据包的id,
      "from":0,
      "type":"A",
      "msg":"success" // 服务端接收到数据包并正确处理了数据包
  }
  L:
  {
       "id":数据包的id,
      "from":0,
      "type":"L",
      "msg":"login in" // wstoken验证通过，已经连接上IM系统
  }
  ~~~

  

**消息数据包**

~~~json
客户端：
t:
{
    id:"",
    "to":接收者id,
    "type":"t",
    "msg":"文本"
}
i:
{
    id:"",
    "to":接收者id,
    "type":"i",
    "msg":聊天信息的id值
}

服务端：
t:
{
    id:"",
    "from":发送者id,
    "type":"t",
    "msg":"文本"
}
i:
{
    id:"",
    "from":发送者id,
    "type":"i",
    "msg":聊天信息的id值
}
s:
{
    id:"",
    "from":发送者id,
    "type":"s",
    "msg":"订单信息"，这个就需要用户通过http的接口去查询了
}
~~~

# 关于前端

* 登录后通过httptoken与http服务器换取wstoken，然后再登录IM，并且在演示3秒后获取拉取服务器的历史信息
* websocket要一直开着，还有每个数据包的id值是由前端控制的，建议取时间戳+随机数构成的随机字符串，数据包发出去并不代表完事，需要根据返回的对应id的响应包来判断消息是否发放成功